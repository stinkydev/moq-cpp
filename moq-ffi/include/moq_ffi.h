/* Auto-generated C header for MOQ FFI */
/* DO NOT EDIT - This file is generated by cbindgen */

/* Generated with cbindgen:0.29.0 */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result codes for MOQ operations
 */
typedef enum MoqResult {
    Success = 0,
    InvalidArgument = 1,
    NetworkError = 2,
    TlsError = 3,
    DnsError = 4,
    GeneralError = 5,
} MoqResult;

/**
 * Configuration for MOQ client
 */
typedef struct MoqClientConfig {
    const char *bind_addr;
    bool tls_disable_verify;
    const char *tls_root_cert_path;
} MoqClientConfig;

/**
 * Opaque handle for the MOQ client
 */
typedef struct MoqClient {
    uint64_t id;
} MoqClient;

/**
 * Opaque handle for a MOQ session
 */
typedef struct MoqSession {
    uint64_t id;
} MoqSession;

/**
 * Opaque handle for a MOQ broadcast producer
 */
typedef struct MoqBroadcastProducer {
    uint64_t id;
} MoqBroadcastProducer;

/**
 * Track information
 */
typedef struct MoqTrack {
    const char *name;
    uint8_t priority;
} MoqTrack;

/**
 * Opaque handle for a MOQ track producer
 */
typedef struct MoqTrackProducer {
    uint64_t id;
} MoqTrackProducer;

/**
 * Opaque handle for a MOQ broadcast consumer
 */
typedef struct MoqBroadcastConsumer {
    uint64_t id;
} MoqBroadcastConsumer;

/**
 * Opaque handle for a MOQ track consumer
 */
typedef struct MoqTrackConsumer {
    uint64_t id;
} MoqTrackConsumer;

/**
 * Opaque handle for a MOQ group producer
 */
typedef struct MoqGroupProducer {
    uint64_t id;
} MoqGroupProducer;

/**
 * Opaque handle for a MOQ group consumer
 */
typedef struct MoqGroupConsumer {
    uint64_t id;
} MoqGroupConsumer;

/**
 * Initialize the MOQ FFI library
 */
enum MoqResult moq_init(void);

/**
 * Create a new MOQ client
 */
enum MoqResult moq_client_new(const struct MoqClientConfig *config, struct MoqClient **client_out);

/**
 * Connect to a MOQ server
 */
enum MoqResult moq_client_connect(struct MoqClient *client,
                                  const char *url,
                                  struct MoqSession **session_out);

/**
 * Free a MOQ client handle
 */
void moq_client_free(struct MoqClient *client);

/**
 * Free a MOQ session handle
 */
void moq_session_free(struct MoqSession *session);

/**
 * Check if a session is connected
 */
bool moq_session_is_connected(const struct MoqSession *session);

/**
 * Close a MOQ session
 */
enum MoqResult moq_session_close(struct MoqSession *session);

/**
 * Create a new broadcast producer
 */
enum MoqResult moq_broadcast_producer_new(struct MoqBroadcastProducer **producer_out);

/**
 * Create a track producer within a broadcast
 */
enum MoqResult moq_broadcast_producer_create_track(struct MoqBroadcastProducer *producer,
                                                   const struct MoqTrack *track,
                                                   struct MoqTrackProducer **track_out);

/**
 * Publish a broadcast on a session
 */
enum MoqResult moq_session_publish(struct MoqSession *session,
                                   const char *broadcast_name,
                                   struct MoqBroadcastProducer *producer);

/**
 * Consume a broadcast from a session
 */
enum MoqResult moq_session_consume(struct MoqSession *session,
                                   const char *broadcast_name,
                                   struct MoqBroadcastConsumer **consumer_out);

/**
 * Subscribe to a track within a broadcast
 */
enum MoqResult moq_broadcast_consumer_subscribe_track(struct MoqBroadcastConsumer *consumer,
                                                      const struct MoqTrack *track,
                                                      struct MoqTrackConsumer **track_out);

/**
 * Create a group within a track producer
 */
enum MoqResult moq_track_producer_create_group(struct MoqTrackProducer *track,
                                               uint64_t sequence,
                                               struct MoqGroupProducer **group_out);

/**
 * Write a frame to a group producer
 */
enum MoqResult moq_group_producer_write_frame(struct MoqGroupProducer *group,
                                              const uint8_t *data,
                                              uintptr_t data_len);

/**
 * Finish a group producer
 */
enum MoqResult moq_group_producer_finish(struct MoqGroupProducer *group);

/**
 * Get the next group from a track consumer (blocking simulation)
 */
enum MoqResult moq_track_consumer_next_group(struct MoqTrackConsumer *track,
                                             struct MoqGroupConsumer **group_out);

/**
 * Read a frame from a group consumer
 */
enum MoqResult moq_group_consumer_read_frame(struct MoqGroupConsumer *group,
                                             uint8_t **data_out,
                                             uintptr_t *data_len_out);

/**
 * Free memory allocated by the FFI layer
 */
void moq_free(uint8_t *ptr);

void moq_broadcast_producer_free(struct MoqBroadcastProducer *producer);

void moq_broadcast_consumer_free(struct MoqBroadcastConsumer *consumer);

void moq_track_producer_free(struct MoqTrackProducer *track);

void moq_track_consumer_free(struct MoqTrackConsumer *track);

void moq_group_producer_free(struct MoqGroupProducer *group);

void moq_group_consumer_free(struct MoqGroupConsumer *group);

/**
 * Get the last error message (placeholder)
 */
const char *moq_get_last_error(void);

/**
 * Convert a MoqResult to a human-readable string
 */
const char *moq_result_to_string(enum MoqResult result);

/**
 * Function to ensure all FFI functions are kept in the binary
 * This prevents dead code elimination of exported functions
 */
void _moq_ffi_keep_symbols(void);

/**
 * Spawn a long-running task in the Tokio runtime
 */
enum MoqResult moq_spawn_task(void (*callback)(void *), void *user_data);

/* End of auto-generated header */
